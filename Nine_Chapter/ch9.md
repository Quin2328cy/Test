#### 动态规划
```
经典动规题-Longest Increasing Subsequence
```

> Triangle
```
记忆化搜索的本质--动态规划
将2^n的复杂度降为n^2--本质-有没有重复计算

尽量使用多重循环来做
反向处理???-自底向上,这样可以尽量保证每一层得到的都是最优的结果

感觉自顶向下很麻烦

滚动数组进行空间优化???
```

```java
/*自底向上*/
A[][] //节点的消耗
f[i][j] //表示从i,j出发到最后一层的最小路径长度
// 初始化,终点先有值
for(int i = 0; i < n; i++){
	f[n-1][i] = A[n-1][i];
}

// 循环递推求解
for(int i = n - 2; i >= 0; i--){
	for(int j = 0; j <= i; j++){
		f[i][j] = Math.min(f[i + 1][j], f[i + 1][j + 1]) + A[i][j];
	}
}

f[0][0]
```

```java
/*自顶向下*/
//初始化,起点
f[0][0] = A[0][0]

//初始化三角形的左边和右边
for(int i = 1; i < n; i++){
	f[i][0] = f[i - 1][0] + A[i][0];
	f[i][i] = f[i - 1][i - 1] + A[i][i];
}

//top down
for(int i = 1; i < n; i++){
	for(int j = 1; j < i; j++){
		f[i][j] = Math.min(f[i - 1][j], f[i - 1][j - 1])+ A[i][j];
	}
}

Math.min(f[n - 1][0], f[n - 1][1], f[n - 1][2]...);

```

> 什么情况下使用动态规划
```
1. 求最大值最小值
2. 判断是否可行
3. 统计方案的个数
则极可能是动态规划求解
```

> 什么情况下不使用动态规划

1. 求出所有 具体 的方案而非方案 个数 
> http://www.lintcode.com/problem/palindrome-partitioning/

2. 输入数据是一个 集合 而不是 序列 
> http://www.lintcode.com/problem/longest-consecutive-sequence/
3. 暴力算法的复杂度已经是多项式级别
```
• 动态规划擅长与优化指数级别复杂度(2^n,n!)到多项式级别复杂度(n^2,n^3)
• 不擅长优化n^3到n^2
```
不用浪费任何时间在贪心上面
> 初始化一个二维的动态规划时,就去初始化第0行和第0列

> Russian Doll Envelope
```
先排序,然后开始计算
```

> 准备补充的知识点
1. DFS的排列组合问题
2. BFS-> 字符转变是怎么转变的--找一下题目是什么-word vector(ladder?)-->拓扑排序复习一下(矩阵上的拓扑排序又是什么)
3. 图论得复习一下啊
